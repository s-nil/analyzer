#ifndef _A_ARRAY_SPARSE_SET_H_
#define _A_ARRAY_SPARSE_SET_H_
#include "AbstractFlowSet"
#include "ValueUniverse"
#include <algorithm>
#include <set>
#include <vector>

namespace A{
    template<typename T>
    class ArraySparseSet : public AbstractFlowSet<T>{
    public:
        ArraySparseSet(){
            elements = std::set<T>();
        }
        ArraySparseSet(const ArraySparseSet& obj){
            elements = obj.elements;
        }
        ArraySparseSet(llvm::Function* F);
        ~ArraySparseSet(){}

        ArraySparseSet<T>* Clone() override;
        ArraySparseSet<T>* EmptySet() override;
        void Copy(ISet<T>* dest) override;
        void Clear() override;
        void Union(ISet<T>* other) override;
        void Union(ISet<T>* other, ISet<T>* dest) override;
        void Intersection(ISet<T>* other) override;
        void Intersection(ISet<T>* other, ISet<T>* dest) override;
        void Difference(ISet<T>* other) override;
        void Difference(ISet<T>* other, ISet<T>* dest) override;
        bool IsEmpty() override;
        int Size() override;
        void Add(T obj) override;
        void Add(T obj, ISet<T>* dest) override;
        void Remove(T obj) override;
        void Remove(T obj, ISet<T>* dest) override;
        bool Contains(T obj) override;
        bool operator==(ISet<T>* other) override;
        bool operator!=(ISet<T>* other) override {return !(*this == other);}
        bool IsSubSet(ISet<T>* other) override;
        std::vector<T> ToList() override;

        typename std::set<T>::iterator begin(){
            return elements.begin();
        }
        typename std::set<T>::iterator end(){
            return elements.end();
        }


    private:
        std::set<T> elements;
        inline ArraySparseSet(const ArraySparseSet<T>* ref);
        bool SameType(A::ISet<T>* o);
    };    

template<typename T>
ArraySparseSet<T>::ArraySparseSet(const ArraySparseSet<T>* ref){
    this->elements = ref->elements;
}

template<typename T>
ArraySparseSet<T>::ArraySparseSet(llvm::Function* F){
    auto universe = ValueUniverse<T>(F);
    auto ele = universe.ToArray();
    this->elements = std::set<T>(ele.begin(),ele.end());
}

template<typename T>
ArraySparseSet<T>* ArraySparseSet<T>::Clone(){
    return new ArraySparseSet<T>(this);
}

template<typename T>
ArraySparseSet<T>* ArraySparseSet<T>::EmptySet(){
    return new ArraySparseSet<T>();
}

template<typename T>
void ArraySparseSet<T>::Copy(ISet<T>* dest){
    if(dest == this){
        return;
    }else{
        if(SameType(dest)){
            ArraySparseSet<T> *tmp = dynamic_cast<ArraySparseSet<T>*>(dest);
            tmp->elements = this->elements;
        }else{
            AbstractFlowSet<T>::Copy(dest);
        }
    }
}

template<typename T>
void ArraySparseSet<T>::Clear(){
    this->elements.clear();
}

template<typename T>
void ArraySparseSet<T>::Union(ISet<T>* other){
    if(this == other){
        return;
    }else{
        if(SameType(other))
            Union(other,this);
        else
            AbstractFlowSet<T>::Union(other);
    }
}

template<typename T>
void ArraySparseSet<T>::Union(ISet<T>* otherFlow, ISet<T>* destFlow){
    if(SameType(otherFlow) && SameType(destFlow)){
        ArraySparseSet<T>* other = dynamic_cast<ArraySparseSet<T>*>(otherFlow);
        ArraySparseSet<T>* dest = dynamic_cast<ArraySparseSet<T>*>(destFlow);

        if(this == other || *this == other){
            Copy(dest);
            return;
        }

        ArraySparseSet<T> tmp;
        std::set_union(elements.begin(),elements.end(),
                        other->elements.begin(),other->elements.end(),
                        std::inserter(tmp.elements,tmp.elements.begin()));
        tmp.Copy(dest);
    }else{
        this->AbstractFlowSet<T>::Union(otherFlow,destFlow);
    }
}

template<typename T>
void ArraySparseSet<T>::Intersection(ISet<T>* other){
    if(this == other){
        return;
    }else{
        if(SameType(other))
            Intersection(other,this);
        else
            AbstractFlowSet<T>::Intersection(other);
    }
}

template<typename T>
void ArraySparseSet<T>::Intersection(ISet<T>* otherFlow, ISet<T>* destFlow){
    if(SameType(otherFlow) && SameType(destFlow)){
        ArraySparseSet<T>* other = dynamic_cast<ArraySparseSet<T>*>(otherFlow);
        ArraySparseSet<T>* dest = dynamic_cast<ArraySparseSet<T>*>(destFlow);

        if(this == other || *this == other){
            Copy(dest);
            return;
        }

        ArraySparseSet<T> tmp;
        std::set_intersection(elements.begin(),elements.end(),
                        other->elements.begin(),other->elements.end(),
                        std::inserter(tmp.elements,tmp.elements.begin()));
        tmp.Copy(dest);
    }else{
        AbstractFlowSet<T>::Intersection(otherFlow,destFlow);
    }
}

template<typename T>
void ArraySparseSet<T>::Difference(ISet<T>* other){
    if(this == other){
        return;
    }else{
        if(SameType(other))
            Difference(other,this);
        else
            AbstractFlowSet<T>::Difference(other);
    }
}

template<typename T>
void ArraySparseSet<T>::Difference(ISet<T>* otherFlow, ISet<T>* destFlow){
    if(SameType(otherFlow) && SameType(destFlow)){
        ArraySparseSet<T>* other = dynamic_cast<ArraySparseSet<T>*>(otherFlow);
        ArraySparseSet<T>* dest = dynamic_cast<ArraySparseSet<T>*>(destFlow);

        if(this == other || *this == other){
            dest->Clear();
            return;
        }

        ArraySparseSet<T> tmp;
        std::set_difference(elements.begin(),elements.end(),
                        other->elements.begin(),other->elements.end(),
                        std::inserter(tmp.elements,tmp.elements.begin()));
        tmp.Copy(dest);
    }else{
        AbstractFlowSet<T>::Difference(otherFlow,destFlow);
    }
}

template<typename T>
bool ArraySparseSet<T>::IsEmpty(){
    return elements.empty();
}

template<typename T>
int ArraySparseSet<T>::Size(){
    return elements.size();
}

template<typename T>
void ArraySparseSet<T>::Add(T obj){
    if(!Contains(obj)){
        elements.insert(obj);
    }
}

template<typename T>
void ArraySparseSet<T>::Add(T obj, ISet<T>* dest){
    auto tmp = this->Clone();
    tmp->Add(obj);
    /// copy tmp to dest
    tmp->Copy(dest);
}

template<typename T>
void ArraySparseSet<T>::Remove(T obj){
    elements.erase(obj);
}

template<typename T>
void ArraySparseSet<T>::Remove(T obj, ISet<T>* dest){
    auto tmp = this->Clone();
    tmp->Remove(obj);
    /// copy tmp to dest
    tmp->Copy(dest);
}

template<typename T>
bool A::ArraySparseSet<T>::Contains(T obj){
    if(elements.find(obj) != elements.end())
        return true;
    return false;
}

template<typename T>
bool ArraySparseSet<T>::operator==(ISet<T>* otherFlow){
    if(SameType(otherFlow)){
        ArraySparseSet<T> *flow = dynamic_cast<ArraySparseSet<T>*>(otherFlow);
        return elements == flow->elements;
    }else{
        return AbstractFlowSet<T>::operator==(otherFlow);
    }
}

template<typename T>
bool ArraySparseSet<T>::IsSubSet(ISet<T>* otherFlow){
    if(SameType(otherFlow)){
        ArraySparseSet<T>* other = dynamic_cast<ArraySparseSet<T>*>(otherFlow);
        return std::includes(elements.begin(),elements.end(),other->elements.begin(),other->elements.end());
    }else{
        return AbstractFlowSet<T>::IsSubSet(otherFlow);
    }
}

template<typename T>
std::vector<T> ArraySparseSet<T>::ToList(){
    std::vector<T> objects(elements.begin(),elements.end());
    return objects;
}

template<typename T>
bool ArraySparseSet<T>::SameType(ISet<T>* o){
    if(dynamic_cast<ArraySparseSet<T>*>(o) != nullptr)
        return true;
    return false;
}
}   //  namespace

#endif
